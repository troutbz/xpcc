// coding: utf-8
/*
* Copyright (c) 2013, Roboterclub Aachen e.V.
* All Rights Reserved.
*
* The file is part for the xpcc library and is released under the
* 3-clause BSD license. See the file `LICENSE` for the full license
* governing this code.
*/
// ----------------------------------------------------------------------------

#ifndef XPCC_KINETIS_UARTHAL_{{ id }}_HPP
#	error 	"Don't include this file directly, use" \
#			"'uart_hal_{{ id }}.hpp' instead!"
#endif

// ----------------------------------------------------------------------------

void
xpcc::kinetis::UartHal{{ id }}::enable()
{
	// enable clock
	SIM_SCGC4 |= SIM_SCGC4_UART{{ id }}_MASK;
}

void
xpcc::kinetis::UartHal{{ id }}::disable()
{
	// clear configuration registers
	UART{{ id }}_C1 = 0x00;
	UART{{ id }}_C2 = 0x00;
	UART{{ id }}_C3 = 0x00;
	// disable clock
	SIM_SCGC4 &= ~SIM_SCGC4_UART{{ id }}_MASK;
}

template<class clockSource, uint32_t baudrate>
void
xpcc::kinetis::UartHal{{ id }}::initialize(Parity parity)
{
	enable();
	setBaudrate<clockSource, baudrate>();
	setParity(parity);
}

void
xpcc::kinetis::UartHal{{ id }}::write(uint8_t data)
{
	UART{{ id }}_D = data;
}

void
xpcc::kinetis::UartHal{{ id }}::read(uint8_t &data)
{
	data = UART{{ id }}_D;
}

void
xpcc::kinetis::UartHal{{ id }}::setParity(const Parity parity)
{
	uint32_t flags = UART{{ id }}_C1;
	flags &= ~(UART_C1_PE_MASK | UART_C1_PT_MASK | UART_C1_M_MASK);
	flags |= static_cast<uint8_t>(parity);
	if (parity != Parity::Disabled) {
		// Parity Bit counts as 9th bit -> enable 9 data bits
		flags |=  UART_C1_M_MASK;
	}
	UART{{ id }}_C1 = flags;
}

template<class clockSource, uint32_t baudrate>
void
xpcc::kinetis::UartHal{{ id }}::setBaudrate()
{
	// baudrate = clockSource::Uart / 16 / (SBR[12:0] + BRFA/32)
	// => fixed point divider: [12:0].[4:0]
	// => divider = clockSource::Uart / 16 / baudrate * 32
	constexpr uint32_t divider = clockSource::Uart{{ id }} * 2 / baudrate;
	UART{{ id }}_BDH = (divider >> 13) & 0x1f; // 5bit
	UART{{ id }}_BDL = (divider >>  4) & 0xff; // 8bit
	UART{{ id }}_C4  = (divider      ) & 0x1f; // 5bit BRFA
}

void
xpcc::kinetis::UartHal{{ id }}::setTransmitterEnable(const bool enable)
{
	if (enable) {
		UART{{ id }}_C2 |=  UART_C2_TE_MASK;
	} else {
		UART{{ id }}_C2 &= ~UART_C2_TE_MASK;
	}
}

void
xpcc::kinetis::UartHal{{ id }}::setReceiverEnable(const bool enable)
{
	if (enable) {
		UART{{ id }}_C2 |=  UART_C2_RE_MASK;
	} else {
		UART{{ id }}_C2 &= ~UART_C2_RE_MASK;
	}
}

bool
xpcc::kinetis::UartHal{{ id }}::isReceiveRegisterNotEmpty()
{
	return UART{{ id }}_S1 & UART_S1_RDRF_MASK;
	// return !(UART{{ id }}_SFIFO & UART_SFIFO_RXEMPT_MASK);
}

bool
xpcc::kinetis::UartHal{{ id }}::isTransmitRegisterEmpty()
{
	return UART{{ id }}_S1 & UART_S1_TDRE_MASK;
	// return UART{{ id }}_SFIFO & UART_SFIFO_TXEMPT_MASK;
}

void
xpcc::kinetis::UartHal{{ id }}::enableInterruptVector(bool enable, uint32_t priority)
{
	if (enable) {
		// Set priority for the interrupt vector
		NVIC_SetPriority(UART{{ id }}_RX_TX_IRQn, priority);

		// register IRQ at the NVIC
		NVIC_EnableIRQ(UART{{ id }}_RX_TX_IRQn);
	}
	else {
		NVIC_DisableIRQ(UART{{ id }}_RX_TX_IRQn);
	}
}

void
xpcc::kinetis::UartHal{{ id }}::enableInterrupt(Interrupt interrupt)
{
	UART{{ id }}_C2 |= (static_cast<uint8_t>(interrupt) & InterruptC2Mask);
	UART{{ id }}_C3 |= (static_cast<uint8_t>(interrupt) & InterruptC3Mask);
}

void
xpcc::kinetis::UartHal{{ id }}::disableInterrupt(Interrupt interrupt)
{
	UART{{ id }}_C2 &= ~(static_cast<uint8_t>(interrupt) & InterruptC2Mask);
	UART{{ id }}_C3 &= ~(static_cast<uint8_t>(interrupt) & InterruptC3Mask);
}

xpcc::kinetis::UartHal{{ id }}::InterruptFlag
xpcc::kinetis::UartHal{{ id }}::getInterruptFlags()
{
	return static_cast<InterruptFlag>( UART{{ id }}_S1 );
}

void
xpcc::kinetis::UartHal{{ id }}::acknowledgeInterruptFlag(InterruptFlag flags)
{
	/* Interrupts must be cleared manually by accessing SR and DR. 
	 * Overrun Interrupt, Noise flag detected, Framing Error, Parity Error
	 * p. 1058 "To clear XXXX, read S1 when XXXX is set and then read D"
	 */ 
	if (flags & (InterruptFlag::OverrunError | InterruptFlag::NoiseError |
				 InterruptFlag::FramingError | InterruptFlag::ParityError)) {
		uint32_t tmp;
		tmp = UART{{ id }}_S1;
		tmp = UART{{ id }}_D;
		(void) tmp;
	}
	(void) flags;	// avoid compiler warning
}


/// ------------ FIFO ---------------------------------------------------------
void
xpcc::kinetis::UartHal{{ id }}::setTransmitFifoEnable(const bool enable)
{
	if(enable) {
		UART{{ id }}_PFIFO |= UART_PFIFO_TXFE_MASK;
	} else {
		UART{{ id }}_PFIFO &= ~UART_PFIFO_TXFE_MASK;
	}
}

void
xpcc::kinetis::UartHal{{ id }}::setReceiveFifoEnable(const bool enable)
{
	if(enable) {
		UART{{ id }}_PFIFO |= UART_PFIFO_RXFE_MASK;
	} else {
		UART{{ id }}_PFIFO &= ~UART_PFIFO_RXFE_MASK;
	}
}

void
xpcc::kinetis::UartHal{{ id }}::setTransmitFifoDepth(const TransmitFifoDepth depth)
{
	UART{{ id }}_PFIFO = (UART{{ id }}_PFIFO & ~UART_PFIFO_TXFIFOSIZE_MASK)
							| static_cast<uint8_t>(depth);
}

void
xpcc::kinetis::UartHal{{ id }}::setReceiveFifoDepth(const ReceiveFifoDepth depth)
{
	UART{{ id }}_PFIFO = (UART{{ id }}_PFIFO & ~UART_PFIFO_RXFIFOSIZE_MASK)
							| static_cast<uint8_t>(depth);
}

void
xpcc::kinetis::UartHal{{ id }}::setTransmitWatermark(const uint8_t watermark)
{
	UART{{ id }}_TWFIFO = watermark;
}

uint8_t
xpcc::kinetis::UartHal{{ id }}::getTransmitCount()
{
	return static_cast<uint8_t>(UART{{ id }}_TCFIFO);
}

void
xpcc::kinetis::UartHal{{ id }}::setReceiveWatermark(const uint8_t watermark)
{
	UART{{ id }}_RWFIFO = watermark;
}

uint8_t
xpcc::kinetis::UartHal{{ id }}::getReceiveCount()
{
	return static_cast<uint8_t>(UART{{ id }}_RCFIFO);
}

void
xpcc::kinetis::UartHal{{ id }}::flushTransmitFifo()
{
	UART{{ id }}_CFIFO |= UART_CFIFO_TXFLUSH_MASK;
}

void
xpcc::kinetis::UartHal{{ id }}::flushReceiveFifo()
{
	UART{{ id }}_CFIFO |= UART_CFIFO_RXFLUSH_MASK;
}

void
xpcc::kinetis::UartHal{{ id }}::enableFifoInterrupt(FifoInterrupt interrupt)
{
	UART{{ id }}_CFIFO |= static_cast<uint8_t>(interrupt);
}

void
xpcc::kinetis::UartHal{{ id }}::disableFifoInterrupt(FifoInterrupt interrupt)
{
	UART{{ id }}_CFIFO &= ~static_cast<uint8_t>(interrupt);
}

xpcc::kinetis::UartHal{{ id }}::FifoInterruptFlag
xpcc::kinetis::UartHal{{ id }}::getFifoInterruptFlags()
{
	return static_cast<FifoInterruptFlag>(UART{{ id }}_SFIFO);
}

xpcc::kinetis::UartHal{{ id }}::FifoStatusFlag
xpcc::kinetis::UartHal{{ id }}::getFifoStatusFlags()
{
	return static_cast<FifoStatusFlag>(UART{{ id }}_SFIFO);
}
