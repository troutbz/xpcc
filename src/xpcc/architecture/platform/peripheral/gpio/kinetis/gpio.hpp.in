// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------
#ifndef XPCC_KINETIS_GPIO_HPP
#define XPCC_KINETIS_GPIO_HPP

#include "../../../device.hpp"
#include "../../../type_ids.hpp"
#include <xpcc/architecture/peripheral/gpio.hpp>
#include "gpio_enable.h"

namespace xpcc
{

namespace kinetis
{

struct Gpio
{
	enum class
	InputType : uint32_t
	{
		Floating = 0b00 << PORT_PCR_PS_SHIFT,
		PullUp   = 0b11 << PORT_PCR_PS_SHIFT,
		PullDown = 0b10 << PORT_PCR_PS_SHIFT,
	};

	enum class
	OutputType : uint32_t
	{
		PushPull  = 0,
		OpenDrain = PORT_PCR_ODE_MASK,
	};

	// TODO: add SlewRate, DriverStrength and PassiveFilter

	static void
	enable()
	{
		xpcc_gpio_enable();
	}

	static void
	disable()
	{
		// FIXME: Implement
	}

protected:
	/// I/O Direction Mode values for this specific pin.
	enum class
	Mode : uint32_t
	{
		Input  = 0x0,
		Output = 0x1,
		AlternateFunction = 0x2,
		Analog = 0x3,
		Mask   = 0x3,
	};

	/// aka Pin Mux Control
	enum class
	AlternateFunction : uint32_t
	{
		Analog = 0b000 << PORT_PCR_MUX_SHIFT,
		Gpio   = 0b001 << PORT_PCR_MUX_SHIFT,
		Af2 = 0b010 << PORT_PCR_MUX_SHIFT,
		Af3 = 0b011 << PORT_PCR_MUX_SHIFT,
		Af4 = 0b100 << PORT_PCR_MUX_SHIFT,
		Af5 = 0b101 << PORT_PCR_MUX_SHIFT,
		Af6 = 0b110 << PORT_PCR_MUX_SHIFT,
		Af7 = 0b111 << PORT_PCR_MUX_SHIFT,
		Mask = Af7,
	};

	/// @private Enum Class To Integer helper functions.
	/// @{
	static constexpr uint32_t
	i(InputType pull) { return static_cast<uint32_t>(pull); }
	static constexpr uint32_t
	i(OutputType out) { return static_cast<uint32_t>(out); }
	static constexpr uint32_t
	i(Mode mode) { return static_cast<uint32_t>(mode); }
	static constexpr uint32_t
	i(AlternateFunction af) { return static_cast<uint32_t>(af); }
	/// @}
};

// Gpio Classes created from the XML Device File Gpio Description
%% for gpio in gpios
	%% set reg_pcr  = "PORT" ~ gpio.port|upper ~ "_PCR" ~ gpio.id
	%% set pin      = gpio.id

	%% for type in ["Output", "Input", ""]
		%% set name = "Gpio" ~ type ~ gpio.port|upper ~ gpio.id
		%% set superclass = "Gpio" ~ (type if type != "" else "IO")

/// {{type if type != "" else "IO"}} class for Pin {{gpio.port|upper ~ pin}}
/// {{gpio.port|upper}}{{gpio.id}} {{type}}
/// @ingroup	kinetis
struct {{name}} : public Gpio, ::xpcc::{{superclass}}
{
private:
	/// Pin Number.
	static constexpr uint8_t pin = {{pin}};
	/// Bitmask
	static constexpr uint32_t mask  = 0x1 << pin;

	/// TODO: Document, maybe rename to setPinMux
	ALWAYS_INLINE static void
	setAlternateFunction(AlternateFunction alt) {
		{{reg_pcr}} =
				({{reg_pcr}} & ~static_cast<uint32_t>(AlternateFunction::Mask))
				| static_cast<uint32_t>(alt);
	}

public:
	ALWAYS_INLINE static void
	configure(OutputType type) {
		if(type == OutputType::PushPull) {
			{{reg_pcr}} &= ~PORT_PCR_ODE_MASK;
		}
		else if(type == OutputType::OpenDrain) {
			{{reg_pcr}} |=  PORT_PCR_ODE_MASK;
		}
	}
	ALWAYS_INLINE static void configure(InputType type) {
		{{reg_pcr}} =	({{reg_pcr}} & ~(0b11 << PORT_PCR_PS_SHIFT))
						| static_cast<uint32_t>(type);
	}
		%% for af in gpio.afs
			%% if af.type == "analog"
	/// {{name}} connects to {{af.name}} of {{af.peripheral}}
	static const ::xpcc::kinetis::{{af.peripheral}}::Channel
	{{af.peripheral}}Channel = ::xpcc::kinetis::{{af.peripheral}}::Channel::{{ af.name }};
			%% endif
		%% endfor
		%% if type in ["" , "Output"]
	// GpioOutput
	// start documentation inherited
	ALWAYS_INLINE static void setOutput() {
		setAlternateFunction(AlternateFunction::Gpio);
		GPIO{{gpio.port|upper}}_PDDR |= mask;
	}
	ALWAYS_INLINE static void setOutput(bool status) {
		set(status);
		setOutput();
	}
	ALWAYS_INLINE static void set() {
		GPIO{{gpio.port|upper}}_PSOR |= mask;
	}
	ALWAYS_INLINE static void set(bool status) {
		if (status) {
			set();
		} else {
			reset();
		}
	}
	ALWAYS_INLINE static void reset() {
		GPIO{{gpio.port|upper}}_PCOR |= mask;
	}
	ALWAYS_INLINE static void toggle() {
		GPIO{{gpio.port|upper}}_PTOR |= mask;
	}
	// stop documentation inherited
	ALWAYS_INLINE static void
	setOutput(OutputType type) {
		configure(type);
		setOutput();
	}
		%% endif
		%% if type in ["", "Input"]
	// GpioInput
	// start documentation inherited
	ALWAYS_INLINE static void
	setInput() {
		setAlternateFunction(AlternateFunction::Gpio);
		GPIO{{gpio.port|upper}}_PDDR &= ~mask;
	}
	ALWAYS_INLINE static bool read() {
		return GPIO{{gpio.port|upper}}_PDIR & mask;
	}
	// end documentation inherited
	ALWAYS_INLINE static void setInput(InputType type) {
		configure(type);
		setInput();
	}
		%% endif
	// connect: Hardware Gpio
		%% for af in gpio.afs
			%% set use = not (	(af.type == "in"  and type == "Output") or
								(af.type == "analog" and type == "Output") or
								(af.type == "out" and type == "Input" ))
			%% if use
	/// Connect {{name}} as {{af.name}} to {{af.peripheral}}.
	ALWAYS_INLINE static void
	connect(TypeId::{{ af.peripheral }}{{ af.name }} /* t */) {
				%% if af.type == "analog"
		setAlternateFunction(AlternateFunction::Analog);
				%% else
		setAlternateFunction(AlternateFunction::Af{{ af.id }});
				%% endif
	}
				%% if af.type in ['', 'out'] and type != "Input"
	/// Connect {{name}} as {{af.name}} to {{af.peripheral}}.
	ALWAYS_INLINE static void
	connect(TypeId::{{ af.peripheral }}{{ af.name }} /* t */,
		OutputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::Af{{ af.id }});
	}
				%% endif
				%% if af.type in ['', 'in'] and type != "Output"
	/// Connect {{name}} as {{af.name}} to {{af.peripheral}}.
	ALWAYS_INLINE static void
	connect(TypeId::{{ af.peripheral }}{{ af.name }} /* t */, InputType type) {
		configure(type);
		setAlternateFunction(AlternateFunction::Af{{ af.id }});
	}
				%% endif
			%% endif
		%% endfor
	// connect: Software Gpio
		%% if type in ['', 'Output']
			%% for peripheral in   ['SoftwareSpiMasterMosi',
									'SoftwareSpiMasterSck']
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {
		configure(OutputType::PushPull);
		setOutput();
		set();
	}
			%% endfor
			%% for peripheral in   ['SoftwareI2cMasterSda',
									'SoftwareI2cMasterScl']
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {
		configure(OutputType::OpenDrain);
		setOutput();
		set();
	}
			%% endfor
		%% endif
		%% if type in ['', 'Input']
			%% for peripheral in ['SoftwareSpiMasterMiso']
	/// Connect to `{{peripheral}}`.
	ALWAYS_INLINE static void
	connect(::xpcc::TypeId::{{ peripheral }}) {
		configure(InputType::Floating);
		setInput();
	}
			%% endfor
		%% endif
};

	%% endfor
%% endfor

// {{gpios | getPorts}}
%% for port in gpios | getPorts
/// Hardware access for port {{port.name}}. 
/// @ingroup kinetis
/*
template< uint8_t START_PIN, uint8_t WIDTH >
class GpioPort{{port.name}} : public ::xpcc::GpioPort, public Gpio
{
	static_assert(START_PIN >= {{port.startPin}}, "START_PIN too small, minimum {{port.startPin}}.");
	static_assert(START_PIN < {{port.startPin + port.width}}, "START_PIN too large, maximum {{port.startPin + port.width-1}}.");
	static_assert(WIDTH <= {{port.width}}, "WIDTH too large, maximum {{port.width}}.");
	static_assert(WIDTH > 0, "WIDTH should be at least 1.");
	static_assert(START_PIN + WIDTH <= {{port.startPin + port.width}}, "START_PIN + WIDTH too large, maximum {{port.startPin + port.width}}.");
	
	static constexpr uint16_t dataMask = (1 << WIDTH) - 1;
	static constexpr uint16_t portMask = dataMask << START_PIN;
	static constexpr uint32_t portMask2 = portMask | (portMask << WIDTH);
	static constexpr uint32_t port01 = 0x55555555 & portMask2;
	static constexpr uint32_t port10 = 0xAAAAAAAA & portMask2;

public:
	static constexpr uint8_t width = WIDTH;
	
public:
	ALWAYS_INLINE static void setOutput() {
		GPIO{{port.name}}->MODER |= port01;
	}
	ALWAYS_INLINE static void setInput() {
		GPIO{{port.name}}->MODER &= ~portMask2;
	}
	ALWAYS_INLINE static void
	configure(OutputType type,
			  OutputSpeed speed = OutputSpeed::MHz50) {
		GPIO{{port.name}}->OTYPER = (GPIO{{port.name}}->OTYPER & ~portMask) | ((type == OutputType::OpenDrain) ? portMask : 0);
		GPIO{{port.name}}->OSPEEDR &= ~portMask2;
		if (i(speed) == 0x01) {
			GPIO{{port.name}}->OSPEEDR |= port01;
		} else if (i(speed) == 0x10) {
			GPIO{{port.name}}->OSPEEDR |= port10;
		} else if (i(speed) == 0x11) {
			GPIO{{port.name}}->OSPEEDR |= portMask2;
		}
	}
	ALWAYS_INLINE static void configure(InputType type) {
		GPIO{{port.name}}->PUPDR &= ~portMask2;
		if (i(type) == 0x01) {
			GPIO{{port.name}}->PUPDR |= port01;
		} else if (i(type) == 0x10) {
			GPIO{{port.name}}->PUPDR |= port10;
		}
	}
	ALWAYS_INLINE static uint16_t read() {
		uint16_t data = GPIO{{port.name}}->IDR & portMask;
		return (data >> START_PIN);
	}
	ALWAYS_INLINE static void write(uint16_t data) {
		data <<= START_PIN;
	%% if target is stm32f2 or target is stm32f4
		GPIO{{port.name}}->BSRRH |= portMask;
		GPIO{{port.name}}->BSRRL |= (data & portMask);
	%% elif target is stm32f0 or target is stm32f3
		GPIO{{port.name}}->BRR  |= portMask;
		GPIO{{port.name}}->BSRR |= (data & portMask);
	%% endif
	}
};
*/

%% endfor

} // namespace kinetis

} // namespace xpcc

#endif // XPCC_KINETIS_GPIO_HPP
