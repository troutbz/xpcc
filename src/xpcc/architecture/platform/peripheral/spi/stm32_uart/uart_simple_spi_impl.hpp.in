// coding: utf-8
/* Copyright (c) 2013, Roboterclub Aachen e.V.
 * All Rights Reserved.
 *
 * The file is part of the xpcc library and is released under the 3-clause BSD
 * license. See the file `LICENSE` for the full license governing this code.
 */
// ----------------------------------------------------------------------------

#include "uart_simple_spi_{{id}}.hpp"

bool xpcc::stm32::UartSpiSimpleMaster{{ id }}::finished = true;

// ----------------------------------------------------------------------------
void
xpcc::stm32::UartSpiSimpleMaster{{ id }}::setDataMode(DataMode /*mode*/)
{
	
}

void
xpcc::stm32::UartSpiSimpleMaster{{ id }}::setDataOrder(DataOrder /*order*/)
{
	
}

uint8_t
xpcc::stm32::UartSpiSimpleMaster{{ id }}::writeReadBlocking(uint8_t /*data*/)
{
	return 0;
}

void
xpcc::stm32::UartSpiSimpleMaster{{ id }}::writeBlocking(uint8_t /*data*/)
{
	
}

bool
xpcc::stm32::UartSpiSimpleMaster{{ id }}::write(uint8_t /*data*/)
{
	return true;
}

uint8_t
xpcc::stm32::UartSpiSimpleMaster{{ id }}::getResult()
{
	return 0;
}

bool
xpcc::stm32::UartSpiSimpleMaster{{ id }}::transfer(uint8_t */*tx*/, uint8_t */*rx*/,
		std::size_t /*length*/)
{
	return true;
}

bool
xpcc::stm32::UartSpiSimpleMaster{{ id }}::isFinished()
{
	return true;
}
